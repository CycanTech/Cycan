// Copyright 2020-2022 Cycan.
// This file is part of Cycan.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// Cycan is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Cycan is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Cycan. If not, see <http://www.gnu.org/licenses/>.

#![cfg_attr(not(feature = "std"), no_std)]


pub use pallet::*;
use sp_core::{ H256, Hasher, ecdsa};
use sp_runtime::AccountId32;
use pallet_evm::AddressMapping;
use frame_support::{
	traits::{IsType},
};
use sp_std::{vec::Vec};
use sha3::{Digest, Keccak256};
use sp_io::hashing::sha2_256;
pub mod weights;
pub use weights::WeightInfo;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

type EthAddress = sp_core::H160;
type EcdsaSignature = ecdsa::Signature;

#[frame_support::pallet]
pub mod pallet {
	use frame_support::{dispatch::DispatchResultWithPostInfo, pallet_prelude::*};
	use frame_support::traits::{Currency, ExistenceRequirement};
	use frame_system::pallet_prelude::*;
	use super::*;

	/// Configure the pallet by specifying the parameters and types on which it depends.
	#[pallet::config]
	pub trait Config: frame_system::Config {
		/// Because this pallet emits events, it depends on the runtime's definition of an event.
		type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
		type Currency: Currency<Self::AccountId>;
		type AddressMapping: AddressMapping<Self::AccountId>;
		/// Weight information for extrinsics in this pallet.
		type WeightInfo: WeightInfo;
	}

	#[pallet::pallet]
	#[pallet::generate_store(pub(super) trait Store)]
	pub struct Pallet<T>(_);

	//The Ethereum address map to Substrate address
	#[pallet::storage]
	#[pallet::getter(fn e2s_map)]
	pub type E2SMap<T: Config> = StorageMap<_, Twox64Concat, EthAddress, T::AccountId, OptionQuery>;

	//The Substrate address map to  Ethereum address
	#[pallet::storage]
	#[pallet::getter(fn s2e_map)]
	pub type S2EMap<T: Config> = StorageMap<_, Twox64Concat, T::AccountId, EthAddress, OptionQuery>;

	#[pallet::event]
	#[pallet::metadata(T::AccountId = "AccountId")]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		BindSuccess(T::AccountId, EthAddress),
	}
	
	// Errors inform users that something went wrong.
	#[pallet::error]
	pub enum Error<T> {
		/// Ethereum address already bind to other substrate address
		OtherBindAlreday,
		/// get a bad signature
		SignatureError,
		/// bind a same address
		BindTheSame,
		/// bind error before
		BindErrorBefore,
		/// param not match
		ParamNotMatch,
		/// S2E and E2S don't have match pair
		BindNotMatch,
	}

	#[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {}

	#[pallet::call]
	impl<T:Config> Pallet<T> {


		/// bind account,make only one substrate address bind one eth address,no matter whether a fake signatrue
		///
		/// - `eth_address`: The eth address bind to the caller's substrate address
		/// - `eth_signature`: A signature generated by the address to prove ownership
		#[pallet::weight(T::WeightInfo::bind_account_if().max(T::WeightInfo::bind_account_else()))]
		pub fn bind_account(
			origin: OriginFor<T>,
			eth_address: EthAddress,
			eth_signature: EcdsaSignature,
		) -> DispatchResultWithPostInfo {
			let who = ensure_signed(origin)?;
			//check if eth address already bind a substrate address or not
			//if so,check if substrate address change bind or not,
			if  S2EMap::<T>::contains_key(&who) {
				let eth_account = S2EMap::<T>::get(&who).ok_or(Error::<T>::BindErrorBefore)?;

				//get eth address
				let recv_address = Self::eth_recover(&eth_signature).ok_or(Error::<T>::SignatureError)?;
				//check param
				if eth_address != recv_address {
					Err(Error::<T>::ParamNotMatch)?;
				}
				//check recover address,is equeal,return
				if eth_account == recv_address {
					Err(Error::<T>::BindTheSame.into())
				} else {
					//check s2emap and e2smap
					let e2s_tmp = E2SMap::<T>::get(eth_account).ok_or(Error::<T>::BindErrorBefore)?;
					if e2s_tmp != who {
						Err(Error::<T>::BindNotMatch)?;
					}
					//change bind to a new eth address,need check is it bind to a substrate address already
					let e2s_recv = E2SMap::<T>::get(recv_address);
					if let Some(_) = e2s_recv {
						Err(Error::<T>::OtherBindAlreday.into())
					} else {
						//need check money,may be exist token transfer
						//get default  AccountId
						let default_acc = T::AddressMapping::into_account_id(eth_address);
						let balance = T::Currency::free_balance(&default_acc);
						if frame_system::Pallet::<T>::account_exists(&default_acc) {
							// merge balance from `evm default address` to `origin`
							T::Currency::transfer(
								&default_acc,
								&who,
								balance,
								ExistenceRequirement::AllowDeath
							)?;
						}
						S2EMap::<T>::remove(&who);
						E2SMap::<T>::remove(&eth_account);
						//now we can bind
						S2EMap::<T>::insert(&who, &recv_address);
						E2SMap::<T>::insert(&recv_address, &who);
						// Emit an event.
						Self::deposit_event(Event::BindSuccess(who, recv_address));
						Ok(().into())
					}
				}
			} else {
				//get eth address
				let recv_address = Self::eth_recover(&eth_signature).ok_or(Error::<T>::SignatureError)?;
				//check param
				if eth_address != recv_address {
					Err(Error::<T>::ParamNotMatch)?;
				}
				//change bind to a new eth address,need check is it bind to a substrate address already
				let e2s_recv = E2SMap::<T>::get(recv_address);
				if let Some(_) = e2s_recv {
					Err(Error::<T>::OtherBindAlreday.into())
				} else {
					//need check money,may be exist token transfer
					//get default  AccountId
					let default_acc = T::AddressMapping::into_account_id(eth_address);
					let balance = T::Currency::free_balance(&default_acc);
					if frame_system::Pallet::<T>::account_exists(&default_acc) {
						// merge balance from `evm default address` to `origin`
						T::Currency::transfer(
							&default_acc,
							&who,
							balance,
							ExistenceRequirement::AllowDeath
						)?;
					}
					//now we can bind
					S2EMap::<T>::insert(&who, &recv_address);
					E2SMap::<T>::insert(&recv_address, &who);
					// Emit an event.
					Self::deposit_event(Event::BindSuccess(who, recv_address));
					Ok(().into())
				}
			}
		}
	}
		#[pallet::genesis_config]
		pub struct GenesisConfig<T: Config> {
			pub e2s:Vec<(EthAddress, T::AccountId)>,
			pub s2e:Vec<(T::AccountId, EthAddress)>,
		}

		#[cfg(feature = "std")]
		impl<T: Config> Default for GenesisConfig<T>
		{
			fn default() -> Self {
				Self {
					e2s:vec![],
					s2e:vec![],
				}
			}
		}

		#[pallet::genesis_build]
		impl<T: Config> GenesisBuild<T> for GenesisConfig<T>
		{
			fn build(&self) {
				self.e2s.iter().for_each(
					|(eth,sub)| {
						E2SMap::<T>::insert(eth,sub)
					});
				self.s2e.iter().for_each(
					|(sub,eth)| {
						S2EMap::<T>::insert(sub,eth)
					});
			}
		}

}

impl<T: Config> Pallet<T> {

	pub fn prepare_sig_data() -> Vec<u8>	{
		//genesis block hash +
		let mut data = Vec::new();
		//get genesis block hash
		let genesis_hash = H256::from_slice(frame_system::Module::<T>::block_hash(T::BlockNumber::from(0 as u32)).as_ref());
		//let genesis_hash = H256::default();
		data.extend_from_slice(genesis_hash.as_bytes());
		data
	}
	#[cfg(any(feature = "runtime-benchmarks", feature = "std"))]
	pub fn secret_buf_wrap(secret: &[u8]) -> libsecp256k1::SecretKey {
		let mut arr = [0u8;32];
		arr.copy_from_slice(secret);
		libsecp256k1::SecretKey::parse(&arr).unwrap()
	}
	#[cfg(any(feature = "runtime-benchmarks", feature = "std"))]
	pub fn eth_sign(secret: &[u8]) -> EcdsaSignature {
		let msg = sha2_256(&Self::prepare_sig_data());
		let (sig, recovery_id) = libsecp256k1::sign(&libsecp256k1::Message::parse(&msg), &Self::secret_buf_wrap(secret));
		let mut r = [0u8; 65];
		r[0..64].copy_from_slice(&sig.serialize()[..]);
		r[64] = recovery_id.serialize();
		EcdsaSignature::from_slice(&r)
	}

	pub fn eth_recover(s: &EcdsaSignature) -> Option<EthAddress> {
		let msg = sha2_256(&Self::prepare_sig_data());
		let mut res = EthAddress::default();
		res.0
			.copy_from_slice(&Keccak256::digest(&sp_io::crypto::secp256k1_ecdsa_recover(&s.0, &msg).ok()?[..])[12..]);
		Some(res)
	}
}
pub struct ESAddressMapping<H, T>(sp_std::marker::PhantomData<H>, sp_std::marker::PhantomData<T>);

impl<H: Hasher<Out = H256>,T:Config> AddressMapping<T::AccountId> for ESAddressMapping<H, T>
	where T::AccountId: IsType<AccountId32> {
	fn into_account_id(address: EthAddress) -> T::AccountId {
		//look up E2SMap,if exist,return,if not,use default formula calculate a address
		if let Some(acc) = E2SMap::<T>::get(address) {
			acc
		} else {
			let mut data = [0u8; 24];
			data[0..4].copy_from_slice(b"evm:");
			data[4..24].copy_from_slice(&address[..]);
			let hash = H::hash(&data);

			AccountId32::from(Into::<[u8; 32]>::into(hash)).into()
		}
	}
}


